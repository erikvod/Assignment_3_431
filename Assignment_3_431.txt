1. Given lambda expressions A and B, show a lambda expression for
                if A then false else B
    Simplify (i.e. apply any feasible lambda-reduction) as much as possible.

2. Given lambda expressions A and B, show a lambda expression for
                A implies (not B)
 Simplify (i.e. apply any feasible lambda-reduction) as much as possible.

3. Given lambda expressions A and B, show a lambda expression for
                A XOR B (A exclusive-OR B)
 Simplify (i.e. apply any feasible lambda-reduction) as much as possible.

4. Define a subset S of Z^2 = Z x Z (=the set of all pairs of negative, zero, positive integers) by the following rules:
                (a) (3,2) element-of S
                (b) if (x,y) element-of S, then (3x â€“ 2y, x) element-of S
 Prove, by structural induction, that every element of S looks in fact like ( 2^(n+1) + 1, 2^n + 1 ).


In my CLASS 20 slides, a binary tree type is defined by the variant
        type 'a btree = Empty | Node of 'a * 'a btree * 'a btree
    (with related OCaml code; refer to that code), and a number of formulas are claimed to hold true,
     including the following

        rev ( inorder ( reflect x ) ) = inorder x (* rev for lists *)
        postorder ( reflect x ) = rev ( preorder x )

5. Prove, by structural induction, that indeed the shown code, in CLASS 20 slides, implies
                rev ( inorder ( reflect x ) ) = inorder x (* rev for lists *)

6. Prove, by structural induction, that indeed the shown code implies
                postorder ( reflect x ) = rev ( preorder x )